/* Multimodal GA. This GA is designed to try to find multiple solutions in a single run.
 * It accomplishes this through an island model genetic algorithm.
 * David Liu
 * The Ohio State University
 * 19 June 2018
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <time.h>
#include <math.h>
#include <random>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <chrono>
#include <thread>
#include <math.h>

using namespace std;

// Headers for our subroutines

void dataRead(vector<vector<vector<float>>> &isleInput, vector<vector<float>> &fitness);

void dataWrite(vector<vector<vector<float>>> isleOutput);

void roulette(vector<vector<vector<float>>> &isleInput, vector<vector<vector<float>>> &isleOutput, vector<float> &fitness);

void migration(vector<vector<vector<float>>> &isleOutput);

// DNA Related Constants

const int NCHROMOSOMES = 1; // Number of chromosomes in data

const int NGENES = 3; // Number of genes in data

const int PARENT_NO = 2; // Number of potential parents per child

const int DNA_GARBAGE_END = 8; // Where in generationDNA.csv the actual data begins.

// Chromosome One, Gene One controls radius currently

const float INITIAL_MEAN_C1_G1 = 1.0f; // When we initially run, this is the average value seeded for the gene.

const float INITIAL_STD_DVN_C1_G1 = 0.25f; // When starting a new generation, this is the starting variance for the gene.

// Chomosome Two, Gene One controls length currently

const float INITIAL_MEAN_C2_G1 = 15.0f; // When we initially run, this is the average value seeded for the gene.

const float INITIAL_STD_DVN_C2_G1 = 10.0f; // When starting a new generation, this is the starting variance for the gene.

// Chomosome Three, Gene One controls angle (in radians) currently

const float INITIAL_MEAN_C3_G1 = M_PI / 8; // When we initially run, this is the average value seeded for the gene.

const float INITIAL_STD_DVN_C3_G1 = M_PI / 8; // When starting a new generation, this is the starting variance for the gene.

// All other genes are currently unused
const float INITIAL_MEAN_CX_GY = 0.0f;

const float INITIAL_STD_DVN_CX_GY = 0.0f;

// ALGORITHM RELATED CONSTANTS

const int CROSSOVER_NO = 4; // Number of unmutated children generated by each roulette run

const int MUTATION_NO = 6; // Number of mutated children generated by each roulette run

const int ISLAND_POP = CROSSOVER_NO + MUTATION_NO; // Population size on each island

const int ISLAND_NO = 5; // Number of islands (5 is plenty)

const float MIGRATION_CHANCE = 0.1f; // Chance for an individual to depart for greener islands

const int MAX_MIGRANT_NO = 1; // Maximum number of people who emigrate from one island whenever there is a migration

const float MUT_MODULATOR = 1.333f; // This is inversely proportional to the magnitude of mutations. At 2, all mutations are halved in magnitude. The higher this goes, the slower evolution becomes.

int main(int argc, char const *argv[])
{
	// First, we declare all our variables
	vector<vector<vector<vector<float>>>> isleInput (ISLAND_NO,vector<vector<vector<float>>>(ISLAND_POP,vector<vector<float> >(NSECTIONS,vector <float>(NVARS, 0.0f))));	
	vector<vector<vector<vector<float>>>> isleOutput (ISLAND_NO,vector<vector<vector<float>>>(ISLAND_POP,vector<vector<float> >(NSECTIONS,vector <float>(NVARS, 0.0f))));
	
	vector<vector<float>> fitness;
	
	/* Data Structures:
	
	Each island has its own population. Genetic Data is stored as a 4D tensor, where:
	
	T represents the island we are looking at
	X represents the individual we are looking at
	Y represents the chromosomes
	Z represents the genes on each chromosomes
	
	So it looks like:
	ISLAND 1
	
	INDIVIDUAL 1
	                 GENE 1     GENE 2    GENE 3     GENE 4      ...     GENE Z
	CHROMOSOME 1    RADIUS 1   LENGTH 1    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 2	RADIUS 2   LENGTH 2    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 3	RADIUS 3   LENGTH 3    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 4	RADIUS 4   LENGTH 4    VAR 3      VAR 4      ...      VAR Z
	... 
	CHROMOSOME Y	RADIUS Y   LENGTH Y    VAR 3       VAR 4     ...      VAR Z

	INDIVIDUAL 2
	                 GENE 1     GENE 2    GENE 3     GENE 4      ...     GENE Z
	CHROMOSOME 1    RADIUS 1   LENGTH 1    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 2	RADIUS 2   LENGTH 2    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 3	RADIUS 3   LENGTH 3    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 4	RADIUS 4   LENGTH 4    VAR 3      VAR 4      ...      VAR Z
	... 
	CHROMOSOME Y	RADIUS Y   LENGTH Y    VAR 3       VAR 4     ...      VAR Z
	
	...
	
	INDIVIDUAL X
	                 GENE 1     GENE 2    GENE 3     GENE 4      ...     GENE Z
	CHROMOSOME 1    RADIUS 1   LENGTH 1    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 2	RADIUS 2   LENGTH 2    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 3	RADIUS 3   LENGTH 3    VAR 3      VAR 4      ...      VAR Z
	CHROMOSOME 4	RADIUS 4   LENGTH 4    VAR 3      VAR 4      ...      VAR Z
	... 
	CHROMOSOME Y	RADIUS Y   LENGTH Y    VAR 3       VAR 4     ...      VAR Z
	
	With each island thereafter having the same individual / chromosome / gene structure.
	---------------------------------------------------------------------------------
	
	Vector fitness stores the actual fitness scores. It's a 2-D matrix, where:
	
	X represents the island we are looking at
	Y represents the individual we are looking at
	
	So it looks like:
	
				INDIVIDUAL 1	INDIVIDUAL 2	INDIVIDUAL_3	...		INDIVIDUAL_Z
	ALPHA		FITNESS_1		FITNESS_2		FITNESS_3		...		FITNESS_Z
	BRAVO		FITNESS_1		FITNESS_2		FITNESS_3		...		FITNESS_Z
	CHARLIE		FITNESS_1		FITNESS_2		FITNESS_3		...		FITNESS_Z
	DELTA		FITNESS_1		FITNESS_2		FITNESS_3		...		FITNESS_Z
	ECHO		FITNESS_1		FITNESS_2		FITNESS_3		...		FITNESS_Z
	
	*/
	
	srand((unsigned)time(0)); // Hey, let's seed our RNG!
	
	// Time to read in our input arguments and parse in our data from the files
	
	cout << "Multimodal algorithm initialized." << endl;
	
	if(argc != 2)
		cout << "Error initializing algorithm. Specify --start or --cont" << endl;
	else
	{
		if(string(argv[1]) == "--start")
		{
			// Here, we generate an initial generation using Gaussian distributions from the
			// initial DNA data assigned up in global constants.
			
			std::default_random_engine generator;
			generator.seed(time(0));
			std::normal_distribution <float> distribution_radius(INITIAL_MEAN_C1_G1, INITIAL_STD_DVN_C1_G1);
			std::normal_distribution <float> distribution_length(INITIAL_MEAN_C2_G1, INITIAL_STD_DVN_C2_G1);
			std::normal_distribution <float> distribution_angle(INITIAL_MEAN_C3_G1, INITIAL_STD_DVN_C3_G1);
			
			for(int i=0;i<ISLAND_NO;i++)
			{
				for(int j=0;j<ISLAND_POP;j++)
				{
					for(int k=0;k<NSECTIONS;k++)
					{
						for(int L=0;L<NVARS;L++)
						{
							if (L == 0)
							{
								float r = distribution_radius(generator);
							
								while(r <= 0)
									r = distribution_radius(generator);
							
							isleOutput[i][j][k][L] = r;
						}
						
						else if (L == 1)
						{
							float r = distribution_length(generator);
							
							while(r <= 0)
								r = distribution_length(generator);
							
							isleOutput[i][j][k][L] = r;
						}

						else if (L == 2)
						{
							float r = distribution_angle(generator);
							
							while(r <= 0)
								r = distribution_angle(generator);
							
							isleOutput[i][j][k][L] = r;
						}
					}
				}
			}
			
			// Now we just write the randomly generated numbers to generationDNA
		dataWrite(isleOutput);
		}
		else if(string(argv[1]) == "--cont")
		{
			// First we read the data
			dataRead(isleInput, fitness);
			
			// Then we breed the data
			roulette(isleInput, isleOutput, fitness);
			
			// Does anyone want to leave their island?
			int migrationCheck = rand()%100;
			
			if (migrationCheck < MIGRATION_CHANCE * 100) // Fly, bitch
			{
				vector<int> emigration_counts (ISLAND_NO, 0);
				int initial_island = rand()%ISLAND_NO + 1;
				bool loop_closed = false;
				int first_receiving_island = rand()%ISLAND_NO + 1;
				vector<float> all_populations (ISLAND_NO, isleAlphaInput);
				
				
				while (first_receiving_island = initial_island)
					first_receiving_island = rand()%ISLAND_NO + 1;
				
